namespace rapp {
namespace cloud {
///
/// asio_handler template implementation
///
template <class T> 
asio_handler<T>::asio_handler(
                               const std::function<void(std::string)> cloud_function,
                               const std::function<void(boost::system::error_code)> error_function,
                               const std::function<void(boost::system::error_code)> shutdown_function
							 )
: http_response(error_function), 
  cloud_cb_(cloud_function), 
  error_cb_(error_function),
  close_cb_(shutdown_function)
  //asio_timer(boost::bind(&asio_handler<T>::has_timed_out, this))
{
    assert(cloud_cb_ && error_cb_);
}

template <class T>
void asio_handler<T>::set_socket(const std::shared_ptr<T> socket)
{
    assert(socket);
    socket_ = socket;
}

template <class T> 
void asio_handler<T>::do_request(const boost::system::error_code & err)
{       
    if (!err) {
        // read until first newline (HTTP 1.1\r\n) - callback `read_status_line`
        boost::asio::async_read_until(*socket_,
                                      http_response::buffer_,
                                      rn_,
                                      boost::bind(&asio_handler<T>::read_status_line, 
                                                  this, 
                                                  boost::asio::placeholders::error));
    }
    else {
        end(err);       
	}
}

template <class T>
void asio_handler<T>::read_status_line(const boost::system::error_code & err)
{
    if (!err) {
        // read entire header (double newlines denote end of HTTP header) - callback `read_headers`
        boost::asio::async_read_until(*socket_,
                                      http_response::buffer_, 
                                      double_rn_,
                                      boost::bind(&asio_handler<T>::read_headers, 
                                                  this, 
                                                  boost::asio::placeholders::error));
    }
    else if (err || !http_response::check_http_header()) {
        end(err);
	}
}

template <class T>
void asio_handler<T>::read_headers(const boost::system::error_code & err)
{
    if (!err) {
        // verify `Content-Length` and use it to read as much
        std::size_t c_len = has_content_length();	
        if (c_len > 0) {
            // remove HTTP header and keep only POST data
            http_response::json_ = http_response::strip_http_header(http_response::to_string());
            // read data into buffer of size `Content-Length` - callback `read_content`
            boost::asio::async_read(*socket_,
                                    http_response::buffer_,
                                    boost::asio::transfer_exactly(c_len),
                                    boost::bind(&asio_handler<T>::read_content, 
                                                this, 
                                                boost::asio::placeholders::error, 
                                                boost::asio::placeholders::bytes_transferred));
        }
        else {
            //end(boost::system::errc::bad_message);
            this->close_cb_(err);
        }
    }
    else {
        end(err);
	}
}

template <class T>
void asio_handler<T>::read_content(
                                    const boost::system::error_code & err,
                                    const std::size_t bytes
                                  )
{
    if (!err) {
        // consume buffer - if transferred bytes >= Content-Length then = EOF && end 
        if (http_response::consume_buffer(cloud_cb_)) {
            close_cb_(err);
        }
        // Continue reading data until we have enough bytes - reccursively calls its self
        boost::asio::async_read(*socket_,
                                http_response::buffer_,
                                boost::asio::transfer_at_least(1),
                                boost::bind(&asio_handler<T>::read_content, 
                                            this, 
                                            boost::asio::placeholders::error, 
                                            boost::asio::placeholders::bytes_transferred));
    }
    else {
        end(err);
	}
}

template<class T>
void asio_handler<T>::has_timed_out() 
{
   end(boost::asio::error::timed_out);
}

template <class T>
void asio_handler<T>::end(const boost::system::error_code & err)
{
    if (err) {
        error_cb_(err);
    }
    http_response::end();
    close_cb_(err);
}

}
}
